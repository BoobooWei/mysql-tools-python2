# MySQL参数检测报告

**当前支持的数据库版本为 5.5 5.6 5.7**

如果不提供主机登陆和数据库只读权限 ，那么，请客户在数据库中执行如下操作：

* 执行 `mysql -uxxx -pxxx -e "show global status;" > mysql_global_status.sql` 将结果保存至`mysql_global_status.sql`文件
* 执行 `mysql -uxxx -pxxx -e "show global variables;” > mysql_global_variables.sql`  将结果保存至`mysql_global_variables.sql`文件
* 将`mysql_global_status.sql` 和 `mysql_global_variables.sql` 从服务器传送到本地，并覆盖当前目录中的文件，注意文件名不要写错了。

在获取到`mysql_global_status.sql`和`mysql_global_variables.sql`后，通过python脚本在本地进行数据库性能诊断。


```bash
# 前提已经按照上面的帮助获取到数据库的全局参数配置和全局状态值，并将文件覆盖当前目录中的 *.sql 文件。
# mysql -uxxx -pxxx -e "show global status;" > mysql_global_status.sql
# mysql -uxxx -pxxx -e "show global variables;” > mysql_global_variables.sql

# 运行后，在report目录中会生成相应的报告
(venv) 02:40 PM :mysql-tools-python2 booboowei$ python get_mysql_tuning.py --VariablesFile mysql_global_variables.sql --StatusFile mysql_global_status.sql
MySQL 参数报告生成成功，请访问 report 目录查看。
```

## 检测算法

| 规则                                         | 描述                                                         | 建议                                                         | 使用的指标项描述                                             | 检测逻辑                                                     |
| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| MySQL  Join没有正确地使用索引                | "您已经有{0}个join，没有使用索引导致需要全表扫描。".format(Select_range_check) | 您可以开启log_queries_not_using_indexes参数，然后在慢速查询日志中查找非索引join语句。     如果您无法优化您的查询，可以增加您的join_buffer_size，以容纳更大的连接。 | Select_full_join =  self.mys['Select_full_join']         Select_range_check =  self.mys['Select_range_check']         join_buffer_size =  self.myv['join_buffer_size']         join_buffer_size =  int(join_buffer_size) + 4096 | if Select_range_check != '0' or  Select_full_join != '0':    |
| MySQL  open_files_limit参数设置不合理        | 比较合适的设置：Open_files  / open_files_limit * 100% <= 75％，open_files_limit配置会影响到客户端的每个请求，如果配置小了可能导致无法访问库表 | 您需要适当调高open_files_limit参数值，注意open_files_limit过大容易导致数据库被OOM。 | open_files_limit =  self.myv['open_files_limit']         Open_files =  self.mys['Open_files']         open_files_ratio =  round((int(Open_files) / float(open_files_limit)), 4) | if open_files_ratio >= 0.75:                                 |
| MySQL  表缓存配置不正常                      | 打开表的数量/打开过的表数量 应该大于等于0.95  ，打开表的数量/表缓存 应该小于等于 0.85， | 您需要提高table_open_cache配置。                             | table_open_cache =  self.myv['table_open_cache']         Open_tables =  self.mys['Open_tables']         Opened_tables = self.mys['Opened_tables']         table_cache_hit_rate =  float(Open_tables) / float(Opened_tables)         table_cache_fill =  float(Open_tables) / float(table_open_cache) | if table_cache_fill >= 0.95  and table_cache_hit_rate <= 0.85: |
| MySQL  临时表配置不合理                      | 当前的  临时表空间大小为：min(mysql_variables_max_heap_table_size,  mysql_variables_tmp_table_size)     临时表配置需要优化，比较理想的配置是：Created_tmp_disk_tables / Created_tmp_tables * 100%  <= 25% | 1. 增加临时表空间；     2. 优化查询语句时，避免使用临时表，如果无法避免，请确保这些临时表在内存中。 | max_heap_table_size =  self.myv['max_heap_table_size']         tmp_table_size =  self.myv['tmp_table_size']         real_tmp_table_size =  min(max_heap_table_size, tmp_table_size)               Created_tmp_disk_tables =  self.mys['Created_tmp_disk_tables']         Created_tmp_files = self.mys['Created_tmp_files']         Created_tmp_tables =  self.mys['Created_tmp_tables']         tmp_table_raito =  '{0:.1}'.format(float(Created_tmp_disk_tables) / float(Created_tmp_tables)) | if tmp_table_raito > 0.25:                                   |
| MySQL  慢查询占比较高                        | 慢查询占比超过10%，查询执行效率低，会导致实例的CPU使用率高，严重情况下直接导致数据库夯住。 | 根据您的工作角色(开发人员、DBA或两者的组合)，您可以优化单个SQL语句、整个应用程序、单个数据库服务器或多个网络数据库服务器的级别。     您可以提前计划并提前计划性能，您也可以在出现问题之后对配置或代码问题进行故障排除。     优化CPU和内存使用情况还可以提高可伸缩性,允许数据库来处理更多的负载没有放缓。 | long_query_time         slow_query_log         slow_query_log_file         min_examined_row_limit           log_queries_not_using_indexes         slow_queries          questions          slow_query_ratio =  round((float(slow_queries) / questions), 2) | if slow_query_log == 'ON' and  slow_query_ratio > 0.1: 慢查询较多需要优化 |
| MySQL  排序缓存配置不合理                    | 当前排序缓存配置不合理，影响SQL执行效率。     Sort_merge_passes 包括两步。MySQL 首先会尝试在内存中做排序，使用的内存大小由系统变量 Sort_buffer_size  决定，如果它的大小不够把所有的记录都读到内存中，MySQL 就会把每次在内存中排序的结果存到临时文件中，等 MySQL  找到所有记录之后，再把临时文件中的记录做一次排序。这再次排序就会增加 Sort_merge_passes。     实际上，MySQL 会用另一个临时文件来存再次排序的结果，所以通常会看到 Sort_merge_passes  增加的数值是建临时文件数的两倍。因为用到了临时文件，所以速度可能会比较慢.          增加 Sort_buffer_size 会减少 Sort_merge_passes 和 创建临时文件的次数。但盲目的增加  Sort_buffer_size 并不一定能提高速度。     另外，增加read_rnd_buffer_size的值对排序的操作也有好处。 | 您应该适当提高sort_buffer_size和  read_rnd_buffer_size配置。 | sort_buffer_size =  self.myv['sort_buffer_size']         read_rnd_buffer_size =  self.myv['read_rnd_buffer_size']         Sort_merge_passes =  self.mys['Sort_merge_passes']         Sort_scan =  self.mys['Sort_scan']         Sort_range =  self.mys['Sort_range']         total_sorts = int(Sort_scan)  + int(Sort_range)         passes_per_sort =  round((float(Sort_merge_passes) / int(total_sorts)), 4) | if passes_per_sort >= 2:                                     |
| MySQL  线程缓存数thread_cache_size配置不合理 | thread_cache_size：当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限）；      即可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，如果线程重新被请求，那么请求将从缓存中读取，如果缓存中是空的或者是新的请求，那么这个线程将被重新创建，如果有很多新的线程，增加这个值可以改善系统性能。 | 您应该增加thread_cache_size。     默认值基于以下公式，上限为100:[8 + (max_connections / 100)]. | thread_cache_size =  self.myv['thread_cache_size']         Threads_created1 =  self.mys['Threads_created']         Threads_created2 =  self.mys['Threads_created']         Threads_cached =  self.mys['Threads_cached']         Uptime =  self.mys['Uptime']         historic_threads_per_sec =  round((float(Threads_created1) / int(Uptime)), 4)         current_threads_per_sec =  round((float(Threads_created2) - int(Threads_created1)), 4)         result = OrderedDict()         result['thread_cache_size'] =  thread_cache_size         result['Threads_created'] =  Threads_created1         result['Threads_cached'] =  Threads_cached           result['historic_threads_per_sec'] = historic_threads_per_sec           result['current_threads_per_sec'] = current_threads_per_sec | if (historic_threads_per_sec  >= 2 or current_threads_per_sec >= 2) and Threads_cached <= 1: |
| MySQL  最大连接数配置不合理                  | 历史最大连接数与数据库最大连接数占比超过了85%，需要对服务器连接配置进行优化，以发挥数据库更好的性能。 | 更改max_connections的值，以实现85%的最大利用率。     增加连接数量将增加每个线程缓冲区使用的RAM的数量。          建议改为：mysql_max_used_connections * 1.25 | 获取全局变量：           max_connections      获取全局状态值：           Threads_connected          Max_used_connections | connections_ratio =  round((float(Max_used_connections) / max_connections), 2)         max_connect_R =  round((Max_used_connections * 1.25), 2)        connections_ratio > 0.85 |
| MySQL存在大量失败连接                        | 存在超过10%的失败连接，代表有大量与数据库的中断连接。     造成这种情况的一个常见原因是，由于连接超时到达，应用程序或锁定的表之间的连接被不正确地关闭，导致随后的连接中断。 | 建议您对代码进行审核，以便正确关闭连接，您可以选择一个临时环境进行测试，以确定问题所在。     Reference =  "http://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#option_mysqld_wait_timeout" | 获取全局状态值     1. Aborted_connects     2. Connections    | (Aborted_connects / Connections)  * 100) > 0.1 不正常        |
